{"name":"6.828","tagline":"Labs of MIT OpenCourseWare 6.828: Operating System Engineering 2011","body":"## Lab 1: Booting a PC\r\n### Part 1: PC Bootstrap\r\n* Study the guide to inline assembly for x86 in Linux. The rules include register naming (%eax), source and destination ordering, immediate operand ($0xffff), indirect memory reference.\r\n* Use the QEMU emulator simulating the x86 hardware to boot the compiled kernel, and use the GNU debugger (GDB) to step through the early boot process.\r\n* Learn the layout of the PC's physical address space including where the BIOS is loaded into and where the memory mapped devices (MMIO) lies.\r\n* Investigate how an IA-32 compatible computer boots.\r\n  + Simplified flow is: BIOS (at physical address 0x000ffff0) => bootloader loaded at IP=0x7c00 => bootloader reads the remaining sectors of the kernel from the disk.\r\n\r\n### Part 2: The Boot Loader\r\n* The bootloader is composed of boot.S and main.c in source code of lab1.\r\n  + The work of boot.S:\r\n    - cli, cld : disable interrupts\r\n    - Enable A20 gate to enable decoding of memory >= 1MB, and load gtdr to fill the segment descriptors table.\r\n    - Switch from real mode to protected mode, by setting bit 0 of CR0, and ljmp to load new %cs.\r\n    - (in protected mode) Set %esp to setup kernel stack growing down from 0x7c00, and call bootmain (the part of bootloader in C).\r\n  + The work of main.c:\r\n    - Read 4096bytes from the 1st sector of harddisk by accessing the I/O port of ATA bus, and decode the ELF header with loading information.\r\n    - The link address of the kernel is at 0x100000 that is defined in kernel.ld\r\n    - Load the kernel to load address (LMA) defined in ELF segment information.\r\n\r\n### Part 3: Kernel\r\n* Map the first 4MB of physical memory using the statically-initialized page directory and page table in kern/entrypgdir.c.\r\n* Program the code to support formatted printing to the console (refer to lib/printfmt.c).\r\n* According to the C calling conventions on the x86 and the content of stack when the nested call instructions execute, implement a stack backtrace function (refer to kern/monitor.c). \r\n* Modify the stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip (refer to kern/kdebug.c).\r\n\r\n## Lab 2: Memory management\r\n### Part 1: Physical Page Management\r\n* Implement the physical page allocator (refer to kern/pmap.c), which requires the knowledge of hardware structures to manage memory in x86 hardware.\r\n  + The translation between logical address, linear address, and physical address.\r\n  + Segmentation: global descriptor table (GDT) and local descriptor table (LDT), segment registers, segment selectors, and the fields affecting how the memory controller translates the addresses\r\n  + Virtual address and page table\r\n\r\n### Part 2: Virtual Memory\r\n* Write a set of routines to manage page tables: to insert and remove linear-to-physical mappings, and to create page table pages when needed (refer to kern/pmap.c).\r\n\r\n### Part 3: Kernel Address Space\r\n* Initialize the kernel address space by completing function mem_init() in kern/pmap.c\r\n  + Set up the address space above UTOP in inc/memlayout.h\r\n\r\n## Lab 3: User Environments\r\n  + Goal: Initially create one user environment, and then design the JOS kernel to support multiple environments.\r\n\r\n### Part A: User Environments and Exception Handling\r\n* a JOS \"environment\" couples the concepts of \"thread\" and \"address space\":\r\n  + The thread is defined by the saved registers (e.g., struct env_tf stands for the trap frame)\r\n  + The address space is defined by the page directory and page tables (i.e., struct env_pgdir)\r\n  + There can be only a JOS environment active in the kernel at a time, so JOS needs only a single kernel stack.\r\n* Modify mem_init() in kern/pmap.c to allocate and map the struct envs array.\r\n* Create and run environments:\r\n  + Because we do not yet have a filesystem, we set up the kernel to load a static binary image that is built-in the kernel itself.\r\n    - Refer to the -b binary option on the linker command line in kern/Makefrag\r\n  + Implement the functions in env.c to set up a JOS user environment:\r\n    - Configures the segmentation hardware with separate segments for privilege level 0 (kernel) and privilege level 3 (user).\r\n      (refer to env_init() in env.c)\r\n      * With the knowledge of 2-level virtual address translation: PDE (entry of page directory) and PTE (entry of page table)\r\n    - Allocate a page directory for a new environment and initialize the kernel portion of the new environment's address space.\r\n      (refer to env_setup_vm() in env.c)\r\n    - Parse an ELF binary image, and load its contents into the user address space of a new environment.\r\n      (refer to load_icode() in env.c)\r\n* Handle interrupts and exceptions:\r\n  + Implement basic exception and system call handling for kernel to recover control of the processor from user-mode code.\r\n      * With the knowledge of the x86 interrupt and exception mechanism\r\n  + An interrupt is a protected control transfer that is caused by an asynchronous event usually external to the processor.\r\n    - The interrupt descriptor table (IDT):\r\n      - Interrupt vectors 0-255, the vector is used as an index into the processor's interrupt descriptor table\r\n      - an IDT entry contains CS, EIP of the instruction of interrupt handler; bit 0-1 of CS stands for the privilege level in which the instruction executes.\r\n    - The task state segment (TSS):\r\n      - A structure specifies the segment selector and address where the stack lives.\r\n      - JOS only uses TSS to define the kernel stack that the processor should switch to when it transfers from user to kernel mode. The processor uses the ESP0 and SS0 fields of the TSS to define the kernel stack when entering kernel mode.\r\n  + Set up the IDT:\r\n    - Edit trapentry.S and trap.c to initialize the IDT with the addresses of the interrupt handlers, and add an entry point in trapentry.S for each trap defined in inc/trap.h.\r\n    - Test the trap handling code using some of the test programs in the user directory that cause exceptions, such as user/divzero.\r\n\r\n### Part B: Page Faults, Breakpoints Exceptions, and System Calls\r\n* Handle page faults:\r\n  + Modify trap_dispatch() in kern/trap.c to dispatch page fault exceptions to page_fault_handler().\r\n    - The page fault exception is handled in interrupt vector 14 (T_PGFLT) that stores the linear address that caused the fault in a special processor control register, CR2.\r\n* The breakpoint exception:\r\n  + Modify trap_dispatch() in kern/trap.c to make breakpoint exceptions invoke the kernel monitor.\r\n    - The breakpoint exception is handled in interrupt vector 3 (T_BRKPT). Debuggers insert breakpoints in a program's code by temporarily replacing the relevant program instruction with the special 1-byte int3 software interrupt instruction.\r\n* System calls:\r\n  + Edit kern/trapentry.S and trap_init() in kern/trap.c to add a handler in the kernel for interrupt vector T_SYSCALL, and change trap_dispatch() to handle the system call interrupt by calling syscall().\r\n    - Use int $0x30 as the system call interrupt, and set up the interrupt descriptor to allow user processes to cause the interrupt.\r\n    - The application passes the system call number and the system call arguments in registers. The kernel passes the return value back in %eax.\r\n* User-mode startup:\r\n  + Modify libmain() in lib/libmain.c to initialize the global pointer thisenv to point at the environment's struct Env in the envs[] array.\r\n    - A user program starts running at the top of lib/entry.S.\r\n  + See that user/hello print \"hello, world\" and then print \"i am environment 00001000\", then attempts to exit by calling sys_env_destroy().\r\n    - The kernel should report that it has destroyed the only environment and then drop into the kernel monitor.\r\n* Page faults and memory protection:\r\n  + Operating systems usually rely on hardware support to implement memory protection.\r\n  + The OS keeps the hardware informed about which virtual addresses are valid and which are not.\r\n  + When a program tries to access an invalid address or one for which it has no permissions, the processor stops the program at the instruction causing the fault and then traps into the kernel with information about the attempted operation.\r\n  + As an example of a fixable fault, consider an automatically extended stack:\r\n    - The kernel initially allocates a single stack page, and then if a program faults accessing pages further down the stack, the kernel will allocate those pages automatically and let the program continue.\r\n  + Change kern/trap.c to panic if a page fault happens in kernel mode.\r\n    - Check the low bits of the struct tf_cs\r\n  + Implement user_mem_check() in kern/pmap.c\r\n    - Read user_mem_assert in kern/pmap.c\r\n  + Change kern/syscall.c to check arguments to system calls\r\n    - Boot the kernel, running user/buggyhello. The environment should be destroyed, and the kernel should not panic.\r\n  + Change debuginfo_eip in kern/kdebug.c to call user_mem_check on usd, stabs, and stabstr.\r\n    - Run user/breakpoint, and run backtrace from the kernel monitor and see the backtrace traverse into lib/libmain.c.\r\n  + Boot the kernel, running user/evilhello. The environment should be destroyed, and the kernel should not panic.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}